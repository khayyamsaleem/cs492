#include <iostream>
#include <cstdlib>
#include <string>
#include <pthread.h>
#include <time.h>
#include <unistd.h>
#include <queue>

#include "prodcons.h"

int num_producers, num_consumers, num_products, queue_size, s_algo, quantum,
		seed;
pthread_mutex_t access_queue;
bool first_thread;
std::queue<Product*> waiting_products;
int num_produced;
pthread_cond_t full_queue, queue_not_full;
clock_t start_time, end_time;

const char* usage() {
	return "Usage: ./prodcons p1 p2 p3 p4 p5 p6 p7\n"
			"        p1: Number of producer threads\n"
			"        p2: Number of consumer threads\n"
			"        p3: Total number of products to be generated by all producer threads\n"
			"        p4: Size of the queue to store products for both producer and consumer threads\n"
			"            (0 for unlimited queue size)\n"
			"        p5: Type of scheduling algorithm (0 for FCFS, 1 for RR)\n"
			"        p6: Value of quantum used for round-robin scheduling\n"
			"        p7: Seed for random number generator";
}

void *producer(void *args) {
	//getting id for producer
	unsigned my_id = *(unsigned *) args;
	while (true) {
		//only create new products if queue is not full and we have products left to create
		pthread_mutex_lock(&access_queue);
		while (waiting_products.size() >= queue_size
				&& num_produced < num_products)
			pthread_cond_wait(&full_queue, &access_queue);
		//only create products if we have to
		if (num_produced < num_products) {
			//use product constructor
			Product *p = new Product(my_id, num_produced++, clock(), rand());
			//protect access to queue
//			pthread_mutex_lock(&access_queue);
			//add to queue
			waiting_products.push(p);
			//print product details
			std::ostringstream os;
			os << *p;
			std::cout << os.str();
			//let other threads know that queue is not yet full
			pthread_cond_broadcast(&queue_not_full);
			//release access to queue
			pthread_mutex_unlock(&access_queue);
			usleep(100000);
		} else {
			//done with all products we needed to make, let other producers know
			pthread_cond_broadcast(&full_queue);
			pthread_mutex_unlock(&access_queue);
			break;
		}
	}
	pthread_exit(NULL);
}

int main(int argc, char* argv[]) {
	if (argc != 8) {
		std::cerr << "Incorrect number of args" << std::endl;
		std::cout << usage() << std::endl;
		std::exit(1);
	}
	for (int i = 1; i < argc; ++i) {
		if ((i <= 4 || i >= 6) && std::atoi(argv[i]) <= 0) {
			std::cerr << "Invalid Value " << argv[i] << " for p" << i
					<< std::endl;
			std::exit(1);
		}
		if (i == 5 && (std::atoi(argv[i]) != 0 && std::atoi(argv[i]) != 1)) {
			std::cerr << "Invalid Value " << argv[i] << " for p5" << std::endl;
			std::exit(1);
		}
	}
	num_producers = std::atoi(argv[1]);
	num_consumers = std::atoi(argv[2]);
	num_products = std::atoi(argv[3]);
	queue_size = std::atoi(argv[4]);
	s_algo = std::atoi(argv[5]);
	quantum = std::atoi(argv[6]);
	seed = std::atoi(argv[7]);

	srand(seed);
	first_thread = true;
	num_produced = 0;
	pthread_mutex_init(&access_queue, NULL);
	pthread_cond_init(&full_queue, NULL);
	pthread_cond_init(&queue_not_full, NULL);

	pthread_t producers[num_producers];
//	pthread_t consumers[num_consumers];
	int p_ids[num_producers];
//	int c_ids[num_consumers];

	//start monitoring time
	start_time = clock();

	for (int i = 0; i < num_producers; ++i) {
		p_ids[i] = i;
		pthread_create(&producers[i], NULL, (void*(*)(void*))(&producer), (void*)&p_ids[i]);
	}
	//join all threads
	for (int i = 0; i < num_producers; ++i)
		pthread_join(producers[i], NULL);
	//	for (int i = 0; i < num_consumers; ++i)
	//		pthread_join(consumers[i], NULL);

	std::cout << "Products in queue: " << waiting_products.size() << std::endl;

	//stop monitoring time
	end_time = clock();

	pthread_mutex_destroy(&access_queue);
	pthread_cond_destroy(&full_queue);

	std::cout << "Time elapsed: "
			<< (float) end_time / CLOCKS_PER_SEC
					- (float) start_time / CLOCKS_PER_SEC << std::endl;

	pthread_exit(0);
}
