#include <iostream>
#include <cstdlib>
#include <string>
#include <pthread.h>
#include <time.h>
#include <unistd.h>
#include <queue>

#include "prodcons.h"

int num_producers;
int num_consumers;
int num_products;
int queue_size;
int s_algo;
int quantum;
int seed;
pthread_mutex_t access_queue;
bool first_thread;
std::queue<Product*> waiting_products;
int num_produced;
pthread_cond_t full_queue;
clock_t start_time;
clock_t end_time;

const char* usage() {
	return "Usage: ./prodcons p1 p2 p3 p4 p5 p6 p7\n"
			"        p1: Number of producer threads\n"
			"        p2: Number of consumer threads\n"
			"        p3: Total number of products to be generated by all producer threads\n"
			"        p4: Size of the queue to store products for both producer and consumer threads\n"
			"            (0 for unlimited queue size)\n"
			"        p5: Type of scheduling algorithm (0 for FCFS, 1 for RR)\n"
			"        p6: Value of quantum used for round-robin scheduling\n"
			"        p7: Seed for randum number generator";
}

//int* spawn_threads(pthread_t* actors, int num_actors, void &to_spawn){
//    int actor_ids[num_actors];
//    for (int i = 0; i < num_actors; ++i){
//        actor_ids[i] = i;
//        pthread_create(&actors[i], NULL, (void*(*)(void*))(to_spawn), (void*)&actor_ids[i]);
//    }
//    return actor_ids;
//}

void *producer(void *args) {
	unsigned my_id = *(unsigned *) args;
	Product *p = new Product(my_id, num_produced++, clock(), 1000);
	pthread_mutex_lock(&access_queue);
	waiting_products.push(p);
	pthread_mutex_unlock(&access_queue);
	usleep(100000);
	std::ostringstream os;
	os << *p;
	std::cout << os.str();
	pthread_exit(NULL);
}

int main(int argc, char* argv[]) {
	if (argc != 8) {
		std::cerr << "Incorrect number of args" << std::endl;
		std::cout << usage() << std::endl;
		std::exit(1);
	}
	for (int i = 1; i < argc; ++i) {
		if ((i <= 4 || i >= 6) && std::atoi(argv[i]) < 0) {
			std::cerr << "Invalid Value " << argv[i] << " for p" << i
					<< std::endl;
			std::exit(1);
		}
		if (i == 5 && (std::atoi(argv[i]) != 0 && std::atoi(argv[i]) != 1)) {
			std::cerr << "Invalid Value " << argv[i] << " for p5" << std::endl;
			std::exit(1);
		}
	}
	num_producers = std::atoi(argv[1]);
	num_consumers = std::atoi(argv[2]);
	num_products = std::atoi(argv[3]);
	queue_size = std::atoi(argv[4]);
	s_algo = std::atoi(argv[5]);
	quantum = std::atoi(argv[6]);
	seed = std::atoi(argv[7]);

	srand(seed);
	first_thread = true;
	num_produced = 0;
	pthread_mutex_init(&access_queue, NULL);
	pthread_cond_init(&full_queue, NULL);

	pthread_t producers[num_producers];
	pthread_t consumers[num_consumers];
	int p_ids[num_producers];
	int c_ids[num_consumers];

	//start monitoring time
	start_time = clock();
	for (int i = 0; i < num_producers; ++i) {
		p_ids[i] = i;
		pthread_create(&producers[i], NULL, (void*(*)(void*))(&producer), (void*)&p_ids[i]);
	}
//	for (int i = 0; i < num_consumers; ++i) {
//		c_ids[i] = i;
//		pthread_create(&consumers[i], NULL, (void*(*)(void*))(&consumer), (void*)&c_ids[i]);
//	}
	//spawn all threads
//    int* producer_ids = spawn_threads(*producers, num_producers, &producer);
//    int* consumer_ids = spawn_threads(*consumers, num_consumers, &consumer);

//join all threads
	for (int i = 0; i < num_producers; ++i)
		pthread_join(producers[i], NULL);
//	for (int i = 0; i < num_consumers; ++i)
//		pthread_join(consumers[i], NULL);

	//stop monitoring time
	end_time = clock();


	pthread_mutex_destroy(&access_queue);
	pthread_cond_destroy(&full_queue);

	std::cout << "Time elapsed: "
			<< (float) end_time / CLOCKS_PER_SEC
					- (float) start_time / CLOCKS_PER_SEC << std::endl;

	pthread_exit(0);
}
