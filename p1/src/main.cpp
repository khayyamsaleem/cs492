#include <iostream>
#include <cstdlib>
#include <string>
#include <pthread.h>
#include <time.h>
#include <unistd.h>
#include <queue>

#include "prodcons.h"

int num_producers, num_consumers, num_products, queue_size, s_algo, quantum,
		seed;
pthread_mutex_t access_queue;
bool first_thread;
std::queue<Product*> waiting_products;
int num_produced, num_consumed;
pthread_cond_t full_queue, queue_not_full;
clock_t start_time, end_time;

const char* usage() {
	return "Usage: ./prodcons p1 p2 p3 p4 p5 p6 p7\n"
			"        p1: Number of producer threads\n"
			"        p2: Number of consumer threads\n"
			"        p3: Total number of products to be generated by all producer threads\n"
			"        p4: Size of the queue to store products for both producer and consumer threads\n"
			"            (0 for unlimited queue size)\n"
			"        p5: Type of scheduling algorithm (0 for FCFS, 1 for RR)\n"
			"        p6: Value of quantum used for round-robin scheduling\n"
			"        p7: Seed for random number generator";
}

void *producer(void *args) {
	//getting id for producer
	unsigned my_id = *(unsigned *) args;
	while (true) {
		//protect access to the queue
		pthread_mutex_lock(&access_queue);
		//only wait if we don't have the unlimited queue size config
		if (queue_size != 0)
			//only create new products if queue is not full and we have products left to create
			while (waiting_products.size() >= queue_size
					&& num_produced < num_products)
				pthread_cond_wait(&full_queue, &access_queue);
		//only create products if we have to
		if (num_produced < num_products) {
			//use product constructor
			Product *p = new Product(my_id, num_produced++, clock(), rand());
			waiting_products.push(p);
			//print product details
			std::ostringstream os;
			os << *p;
			std::cout << os.str();
			//let other threads know that queue is not yet full
			pthread_cond_broadcast(&queue_not_full);
			//release access to queue
			pthread_mutex_unlock(&access_queue);
			//100000 Âµs == 100ms
			usleep(100000);
		} else {
			//done with all products we needed to make, let other producers know
			pthread_cond_broadcast(&full_queue);
			//release queue
			pthread_mutex_unlock(&access_queue);
			break;
		}
	}
	pthread_exit(NULL);
}

unsigned fn(unsigned n) {
	return (n == 0 || n == 1) ? n : fn(n - 1) + fn(n - 2);
}

void *consumer(void *args) {
	int my_id = *(int *) args;
	while (true) {
		pthread_mutex_lock(&access_queue);
		while (waiting_products.size() == 0 && num_consumed < num_products)
			pthread_cond_wait(&queue_not_full, &access_queue);
		//check if there are any products left to consume
		//and which algorithm to use
		Product *p = waiting_products.front();
		waiting_products.pop();
		if (num_consumed < num_products && s_algo == 0) { //FCFS
			++num_consumed;
			//let producers know that there's space
			pthread_cond_broadcast(&full_queue);
			pthread_mutex_unlock(&access_queue);
			for (int i = 0; i < p->life; ++i)
				fn(10);
			std::ostringstream os;
			os << "Consumer " << my_id << " consumed " << *p;
			std::cout << os.str();
			usleep(100000);
		} else if (num_consumed < num_products && s_algo == 1) { //ROUND ROBIN
		//round robin
		//if there is still some life left, we've gta keep running the func
		//and put the product back in the queue
		// "taking a bite"
			if (p->life >= quantum) {
				//reducing life
				p->life -= quantum;
				//simulating consumption of a product
				for (int i = 0; i < quantum; ++i) fn(10);
				//reinsert product in queue
				waiting_products.push(p);
				//inform ONLY consumers that the product is back in the queue
				pthread_cond_broadcast(&queue_not_full);
			} else {
				//case where there is less than a quantum of life left,
				//finish consuming ("finishing the meal")
				++num_consumed;
				//tell producers that we've made room in the queue
				pthread_cond_broadcast(&full_queue);
				//finish the remainder
				for (int i = 0; i < p->life; ++i) fn(10);
				std::ostringstream os;
				os << "Consumer " << my_id << " consumed " << *p;
				std::cout << os.str();
			}
			pthread_mutex_unlock(&access_queue);
			usleep(100000);
		} else {
			//consumed all products, tell consumers to chill out
			pthread_cond_broadcast(&queue_not_full);
			pthread_mutex_unlock(&access_queue);
			break;
		}
	}
	pthread_exit(NULL);
}

int main(int argc, char* argv[]) {
	if (argc != 8) {
		std::cerr << "Incorrect number of args" << std::endl;
		std::cout << usage() << std::endl;
		std::exit(1);
	}
	for (int i = 1; i < argc; ++i) {
		if ((i <= 4 || i >= 6) && std::atoi(argv[i]) < 0) {
			std::cerr << "Invalid Value " << argv[i] << " for p" << i
					<< std::endl;
			std::exit(1);
		}
		if (i == 5 && (std::atoi(argv[i]) != 0 && std::atoi(argv[i]) != 1)) {
			std::cerr << "Invalid Value " << argv[i] << " for p5" << std::endl;
			std::exit(1);
		}
	}
	num_producers = std::atoi(argv[1]);
	num_consumers = std::atoi(argv[2]);
	num_products = std::atoi(argv[3]);
	queue_size = std::atoi(argv[4]);
	s_algo = std::atoi(argv[5]);
	quantum = std::atoi(argv[6]);
	seed = std::atoi(argv[7]);

	srand(seed);
	first_thread = true;
	num_produced = 0;
	num_consumed = 0;
	pthread_mutex_init(&access_queue, NULL);
	pthread_cond_init(&full_queue, NULL);
	pthread_cond_init(&queue_not_full, NULL);

	pthread_t producers[num_producers];
	pthread_t consumers[num_consumers];
	int p_ids[num_producers];
	int c_ids[num_consumers];

	//start monitoring time
	start_time = clock();

	for (int i = 0; i < num_producers; ++i) {
		p_ids[i] = i;
		pthread_create(&producers[i], NULL, (void*(*)(void*))(&producer), (void*)&p_ids[i]);
	}
	for (int i = 0; i < num_consumers; ++i) {
		c_ids[i] = i;
		pthread_create(&consumers[i], NULL, (void*(*)(void*))(&consumer), (void*)&c_ids[i]);
	}
	//join all threads
	for (int i = 0; i < num_producers; ++i)
		pthread_join(producers[i], NULL);
	for (int i = 0; i < num_consumers; ++i)
		pthread_join(consumers[i], NULL);

	std::cout << "Products in queue: " << waiting_products.size() << std::endl;

	//stop monitoring time
	end_time = clock();

	pthread_mutex_destroy(&access_queue);
	pthread_cond_destroy(&full_queue);

	std::cout << "Time elapsed: "
			<< (float) end_time / CLOCKS_PER_SEC
					- (float) start_time / CLOCKS_PER_SEC << std::endl;

	pthread_exit(0);
	std::exit(0);
}
